[
    {
        "ruleId": "code-complexity",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Function has cyclomatic complexity \"current\" but allowed no more than maxcompl.",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "Maximum allowed cyclomatic complexity",
                        "default": 7
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Low code complexity",
                            "code": " if (a > b) {                   \n   if (b > c) {                 \n     if (c > d) {               \n     }                          \n   }                            \n }                              \nfor (i = 0; i < b; i += 1) { }  \ndo { d++; } while (b > c);       \nwhile (d > e) { }               "
                        }
                    ],
                    "bad": [
                        {
                            "description": "High code complexity",
                            "code": " if (a > b) {                   \n   if (b > c) {                 \n     if (c > d) {               \n       if (d > e) {             \n       } else {                 \n       }                        \n     }                          \n   }                            \n }                              \nfor (i = 0; i < b; i += 1) { }  \ndo { d++; } while (b > c);       \nwhile (d > e) { }               "
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": [
                "warn",
                7
            ],
            "schema": {
                "type": "integer"
            }
        },
        "file": "/solhint/lib/rules/best-practises/code-complexity.js"
    },
    {
        "ruleId": "custom-errors",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Enforces the use of Custom Errors over Require and Revert statements",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Use of Custom Errors",
                            "code": "revert CustomErrorFunction();"
                        },
                        {
                            "description": "Use of Custom Errors with arguments",
                            "code": "revert CustomErrorFunction({ msg: \"Insufficient Balance\" });"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Use of require statement",
                            "code": "require(userBalance >= availableAmount, \"Insufficient Balance\");"
                        },
                        {
                            "description": "Use of plain revert statement",
                            "code": "revert();"
                        },
                        {
                            "description": "Use of revert statement with message",
                            "code": "revert(\"Insufficient Balance\");"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/custom-errors.js"
    },
    {
        "ruleId": "explicit-types",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Forbid or enforce explicit types (like uint256) that have an alias (like uint).",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "Options need to be one of \"explicit\", \"implicit\"",
                        "default": "explicit"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "If explicit is selected",
                            "code": "uint256 public variableName"
                        },
                        {
                            "description": "If implicit is selected",
                            "code": "uint public variableName"
                        },
                        {
                            "description": "If explicit is selected",
                            "code": "uint256 public variableName = uint256(5)"
                        }
                    ],
                    "bad": [
                        {
                            "description": "If explicit is selected",
                            "code": "uint public variableName"
                        },
                        {
                            "description": "If implicit is selected",
                            "code": "uint256 public variableName"
                        },
                        {
                            "description": "At any setting",
                            "code": "uint public variableName = uint256(5)"
                        }
                    ]
                },
                "notes": [
                    {
                        "note": "Solhint allows this rule to automatically fix the code with `--fix` option"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": [
                "warn",
                "explicit"
            ],
            "fixable": true,
            "schema": {
                "type": "string",
                "enum": [
                    "explicit",
                    "implicit"
                ]
            }
        },
        "file": "/solhint/lib/rules/best-practises/explicit-types.js"
    },
    {
        "ruleId": "function-max-lines",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Function body contains \"count\" lines but allowed no more than maxlines.",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "Maximum allowed lines count per function",
                        "default": 50
                    }
                ]
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": [
                "warn",
                50
            ],
            "schema": {
                "type": "integer",
                "minimum": 1
            }
        },
        "file": "/solhint/lib/rules/best-practises/function-max-lines.js"
    },
    {
        "ruleId": "max-line-length",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Line length must be no more than maxlen.",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "error"
                    },
                    {
                        "description": "Maximum allowed number of characters per line",
                        "default": 120
                    }
                ]
            },
            "isDefault": true,
            "recommended": false,
            "defaultSetup": [
                "error",
                120
            ],
            "schema": {
                "type": "integer",
                "minimum": 1
            }
        },
        "file": "/solhint/lib/rules/best-practises/max-line-length.js"
    },
    {
        "ruleId": "max-states-count",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Contract has \"some count\" states declarations but allowed no more than maxstates.",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "Maximum allowed number of states declarations",
                        "default": 15
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Low number of states",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n                uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n        uint private constant TEST = 1;\n      }\n    "
                        }
                    ],
                    "bad": [
                        {
                            "description": "High number of states",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n                uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n        uint private a;\n      }\n    "
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": [
                "warn",
                15
            ],
            "schema": {
                "type": "integer"
            }
        },
        "file": "/solhint/lib/rules/best-practises/max-states-count.js"
    },
    {
        "ruleId": "no-console",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "No console.log/logInt/logBytesX/logString/etc & No hardhat and forge-std console.sol import statements.",
                "category": "Best Practise Rules",
                "examples": {
                    "bad": [
                        {
                            "description": "No console.logX statements",
                            "code": "console.log('test')"
                        },
                        {
                            "description": "No hardhat/console.sol import statements",
                            "code": "import \"hardhat/console.sol\""
                        },
                        {
                            "description": "No forge-std console.sol & console2.sol import statements",
                            "code": "import \"forge-std/consoleN.sol\""
                        }
                    ]
                }
            },
            "isDefault": true,
            "recommended": true,
            "defaultSetup": "error",
            "fixable": true,
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/no-console.js"
    },
    {
        "ruleId": "no-empty-blocks",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Code block has zero statements inside. Exceptions apply.",
                "category": "Best Practise Rules",
                "examples": {
                    "bad": [
                        {
                            "description": "Empty block on if statement",
                            "code": "if (condition) { }"
                        },
                        {
                            "description": "Empty contract",
                            "code": "contract Foo { }"
                        },
                        {
                            "description": "Empty block in constructor without parent initialization",
                            "code": "constructor () { }"
                        }
                    ],
                    "good": [
                        {
                            "description": "Empty fallback function",
                            "code": "fallback () external { }"
                        },
                        {
                            "description": "Empty constructor with member initialization list",
                            "code": "constructor(uint param) Foo(param) Bar(param*2) { }"
                        }
                    ]
                },
                "notes": [
                    {
                        "note": "The rule ignores an empty constructor by default as long as base contracts are being inherited. See \"Empty Constructor\" example."
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/no-empty-blocks.js"
    },
    {
        "ruleId": "no-global-import",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Import statement includes an entire file instead of selected symbols.",
                "category": "Best Practise Rules",
                "examples": {
                    "bad": [
                        {
                            "description": "import all members from a file",
                            "code": "import * from \"foo.sol\""
                        },
                        {
                            "description": "import an entire file",
                            "code": "import \"foo.sol\""
                        }
                    ],
                    "good": [
                        {
                            "description": "import names explicitly",
                            "code": "import {A} from \"./A.sol\""
                        },
                        {
                            "description": "import entire file into a name",
                            "code": "import \"./A.sol\" as A"
                        },
                        {
                            "description": "import entire file into a name",
                            "code": "import * as A from \"./A.sol\""
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/no-global-import.js"
    },
    {
        "ruleId": "no-unused-import",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Imported object name is not being used by the contract.",
                "category": "Best Practise Rules",
                "examples": {
                    "good": [
                        {
                            "description": "Imported object is being used",
                            "code": "\n            import { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n            contract MyToken is ERC20 {}\n          "
                        }
                    ],
                    "bad": [
                        {
                            "description": "Imported object is not being used",
                            "code": "\n          import { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n            contract B {}\n          "
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/no-unused-import.js"
    },
    {
        "ruleId": "no-unused-vars",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Variable \"name\" is unused.",
                "category": "Best Practise Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/no-unused-vars.js"
    },
    {
        "ruleId": "one-contract-per-file",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Enforces the use of ONE Contract per file see [here](https://docs.soliditylang.org/en/v0.8.21/style-guide.html#contract-and-library-names)",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/one-contract-per-file.js"
    },
    {
        "ruleId": "payable-fallback",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "When fallback is not payable you will not be able to receive ethers.",
                "category": "Best Practise Rules",
                "examples": {
                    "good": [
                        {
                            "description": "Fallback is payable",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        function () public payable {}\n      }\n    "
                        }
                    ],
                    "bad": [
                        {
                            "description": "Fallback is not payable",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        function () public {}\n      }\n    "
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "fixable": true,
            "schema": null
        },
        "file": "/solhint/lib/rules/best-practises/payable-fallback.js"
    },
    {
        "ruleId": "reason-string",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Require or revert statement must have a reason string and check that each reason string is at most N characters long.",
                "category": "Best Practise Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "A JSON object with a single property \"maxLength\" specifying the max number of characters per reason string.",
                        "default": "{\"maxLength\":32}"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Require with reason string",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n        function b() public {\n          require(!has(role, account), \"Roles: account already has role\");\n          role.bearer[account] = true;\n          role.bearer[account] = true;\n        }\n    \n      }\n    "
                        }
                    ],
                    "bad": [
                        {
                            "description": "Require without reason string",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n        function b() public {\n          require(!has(role, account));\n          role.bearer[account] = true;\n          role.bearer[account] = true;\n        }\n    \n      }\n    "
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": [
                "warn",
                {
                    "maxLength": 32
                }
            ],
            "schema": {
                "type": "object",
                "properties": {
                    "maxLength": {
                        "type": "integer"
                    }
                }
            }
        },
        "file": "/solhint/lib/rules/best-practises/reason-string.js"
    },
    {
        "ruleId": "constructor-syntax",
        "meta": {
            "type": "best-practises",
            "docs": {
                "description": "Constructors should use the new constructor keyword.",
                "category": "Best Practise Rules"
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/deprecations/constructor-syntax.js"
    },
    {
        "ruleId": "comprehensive-interface",
        "meta": {
            "type": "miscellaneous",
            "docs": {
                "description": "Check that all public or external functions are override. This is iseful to make sure that the whole API is extracted in an interface.",
                "category": "Miscellaneous",
                "examples": {
                    "good": [
                        {
                            "description": "All public functions are overrides",
                            "code": "pragma solidity ^0.7.0;\n\ncontract Foo is FooInterface {\n  function foo() public override {}\n}\n"
                        }
                    ],
                    "bad": [
                        {
                            "description": "A public function is not an override",
                            "code": "pragma solidity ^0.7.0;\n\ncontract Foo {\n  function foo() public {}\n}\n"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/miscellaneous/comprehensive-interface.js"
    },
    {
        "ruleId": "quotes",
        "meta": {
            "type": "miscellaneous",
            "docs": {
                "description": "Enforces the use of double or simple quotes as configured for string literals. Values must be 'single' or 'double'.",
                "category": "Miscellaneous",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "error"
                    },
                    {
                        "description": "Type of quotes. Must be one of \"single\", \"double\"",
                        "default": "double"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Configured with double quotes",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        string private a = \"test\";\n      }\n    "
                        },
                        {
                            "description": "Configured with single quotes",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        string private a = 'test';\n      }\n    "
                        },
                        {
                            "description": "Configured with double quotes",
                            "code": "string private constant STR = \"You shall 'pass' !\";"
                        },
                        {
                            "description": "Configured with single quotes",
                            "code": "string private constant STR = 'You shall \"pass\" !';"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Configured with single quotes",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        string private a = \"test\";\n      }\n    "
                        },
                        {
                            "description": "Configured with double quotes",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        string private a = 'test';\n      }\n    "
                        }
                    ]
                },
                "notes": [
                    {
                        "note": "This rule allows to put a double quote inside single quote string and viceversa"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": [
                "error",
                "double"
            ],
            "schema": {
                "type": "string",
                "enum": [
                    "single",
                    "double"
                ]
            }
        },
        "file": "/solhint/lib/rules/miscellaneous/quotes.js"
    },
    {
        "ruleId": "const-name-snakecase",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Constant name must be in capitalized SNAKE_CASE. (Does not check IMMUTABLES, use immutable-vars-naming)",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/const-name-snakecase.js"
    },
    {
        "ruleId": "contract-name-camelcase",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Contract name must be in CamelCase.",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/contract-name-camelcase.js"
    },
    {
        "ruleId": "event-name-camelcase",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Event name must be in CamelCase.",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/event-name-camelcase.js"
    },
    {
        "ruleId": "foundry-test-functions",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Enforce naming convention on functions for Foundry test cases",
                "category": "Style Guide Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "off"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Foundry test case with correct Function declaration",
                            "code": "function test_NumberIs42() public {}"
                        },
                        {
                            "description": "Foundry test case with correct Function declaration",
                            "code": "function testFail_Subtract43() public {}"
                        },
                        {
                            "description": "Foundry test case with correct Function declaration",
                            "code": "function testFuzz_FuzzyTest() public {}"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Foundry test case with incorrect Function declaration",
                            "code": "function numberIs42() public {}"
                        }
                    ]
                },
                "notes": [
                    {
                        "note": "This rule can be configured to skip certain function names in the SKIP array. In Example Config. ```setUp``` function will be skipped"
                    },
                    {
                        "note": "Supported Regex: ```test(Fork)?(Fuzz)?(Fail)?_(Revert(If_|When_){1})?\\w{1,}```"
                    },
                    {
                        "note": "This rule should be executed in a separate folder with a separate .solhint.json => ```solhint --config .solhint.json testFolder/**/*.sol```"
                    },
                    {
                        "note": "This rule applies only to `external` and `public` functions"
                    },
                    {
                        "note": "This rule skips the `setUp()` function by default"
                    }
                ]
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": [
                "off",
                [
                    "setUp"
                ]
            ],
            "schema": {
                "type": "array"
            }
        },
        "file": "/solhint/lib/rules/naming/foundry-test-functions.js"
    },
    {
        "ruleId": "func-name-mixedcase",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Function name must be in mixedCase.",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/func-name-mixedcase.js"
    },
    {
        "ruleId": "func-named-parameters",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Enforce named parameters for function calls with 4 or more arguments. This rule may have some false positives",
                "category": "Style Guide Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "Minimum qty of unnamed parameters for a function call (to prevent false positives on builtin functions).",
                        "default": "4"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Function call with two UNNAMED parameters (default is 4)",
                            "code": "functionName('0xA81705c8C247C413a19A244938ae7f4A0393944e', 1e18)"
                        },
                        {
                            "description": "Function call with two NAMED parameters",
                            "code": "functionName({ sender: '0xA81705c8C247C413a19A244938ae7f4A0393944e', amount: 1e18})"
                        },
                        {
                            "description": "Function call with four NAMED parameters",
                            "code": "functionName({ sender: _senderAddress, amount: 1e18, token: _tokenAddress, receiver: _receiverAddress })"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Function call with four UNNAMED parameters (default 4)",
                            "code": "functionName(_senderAddress, 1e18, _tokenAddress, _receiverAddress )"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": [
                "warn",
                4
            ],
            "schema": {
                "type": "integer"
            }
        },
        "file": "/solhint/lib/rules/naming/func-named-parameters.js"
    },
    {
        "ruleId": "func-param-name-mixedcase",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Function param name must be in mixedCase.",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/func-param-name-mixedcase.js"
    },
    {
        "ruleId": "immutable-vars-naming",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Check Immutable variables. Capitalized SNAKE_CASE or mixedCase depending on configuration.",
                "category": "Style Guide Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "A JSON object with a single property \"immutablesAsConstants\" as boolean specifying if immutable variables should be treated as constants",
                        "default": "{\"immutablesAsConstants\":true}"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": [
                "warn",
                {
                    "immutablesAsConstants": true
                }
            ],
            "schema": {
                "type": "object",
                "properties": {
                    "immutablesAsConstants": {
                        "type": "boolean"
                    }
                }
            }
        },
        "file": "/solhint/lib/rules/naming/immutable-vars-naming.js"
    },
    {
        "ruleId": "modifier-name-mixedcase",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Modifier name must be in mixedCase.",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/modifier-name-mixedcase.js"
    },
    {
        "ruleId": "named-parameters-mapping",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Solidity v0.8.18 introduced named parameters on the mappings definition.",
                "category": "Style Guide Rules",
                "examples": {
                    "good": [
                        {
                            "description": "To enter \"users\" mapping the key called \"name\" is needed to get the \"balance\"",
                            "code": "mapping(string name => uint256 balance) public users;"
                        },
                        {
                            "description": "To enter owner token balance, the main key \"owner\" enters another mapping which its key is \"token\" to get its \"balance\"",
                            "code": "mapping(address owner => mapping(address token => uint256 balance)) public tokenBalances;"
                        },
                        {
                            "description": "Main key of mapping is enforced. On nested mappings other naming are not neccesary",
                            "code": "mapping(address owner => mapping(address => uint256)) public tokenBalances;"
                        },
                        {
                            "description": "Main key of the parent mapping is enforced. No naming in nested mapping uint256",
                            "code": "mapping(address owner => mapping(address token => uint256)) public tokenBalances;"
                        },
                        {
                            "description": "Main key of the parent mapping is enforced. No naming in nested mapping address",
                            "code": "mapping(address owner => mapping(address => uint256 balance)) public tokenBalances;"
                        }
                    ],
                    "bad": [
                        {
                            "description": "No naming at all in regular mapping ",
                            "code": "mapping(address => uint256)) public tokenBalances;"
                        },
                        {
                            "description": "Missing any variable name in regular mapping uint256",
                            "code": "mapping(address token => uint256)) public tokenBalances;"
                        },
                        {
                            "description": "Missing any variable name in regular mapping address",
                            "code": "mapping(address => uint256 balance)) public tokenBalances;"
                        },
                        {
                            "description": "No MAIN KEY naming in nested mapping. Other naming are not enforced",
                            "code": "mapping(address => mapping(address token => uint256 balance)) public tokenBalances;"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "off",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/named-parameters-mapping.js"
    },
    {
        "ruleId": "named-return-values",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Enforce the return values of a function to be named",
                "category": "Style Guide Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Function definition with named return values",
                            "code": "function checkBalance(address wallet) external view returns(uint256 retBalance) {}"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Function definition with UNNAMED return values",
                            "code": "function checkBalance(address wallet) external view returns(uint256) {}"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/named-return-values.js"
    },
    {
        "ruleId": "private-vars-leading-underscore",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Non-external functions and state variables should start with a single underscore. Others, shouldn't",
                "category": "Style Guide Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "A JSON object with a single property \"strict\" specifying if the rule should apply to ALL non state variables. Default: { strict: false }.",
                        "default": "{\"strict\":false}"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Internal function with correct naming",
                            "code": "function _thisIsInternal() internal {}"
                        },
                        {
                            "description": "Private function with correct naming",
                            "code": "function _thisIsPrivate() private {}"
                        },
                        {
                            "description": "Internal state variable with correct naming",
                            "code": "uint256 internal _thisIsInternalVariable;"
                        },
                        {
                            "description": "Internal state variable with correct naming (no visibility is considered internal)",
                            "code": "uint256 _thisIsInternalVariable;"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Internal function with incorrect naming",
                            "code": "function thisIsInternal() internal {}"
                        },
                        {
                            "description": "Private function with incorrect naming",
                            "code": "function thisIsPrivate() private {}"
                        },
                        {
                            "description": "Internal state variable with incorrect naming",
                            "code": "uint256 internal thisIsInternalVariable;"
                        },
                        {
                            "description": "Internal state variable with incorrect naming (no visibility is considered internal)",
                            "code": "uint256 thisIsInternalVariable;"
                        }
                    ]
                },
                "notes": [
                    {
                        "note": "This rule DO NOT considers functions and variables in Libraries"
                    },
                    {
                        "note": "This rule skips external and public functions"
                    },
                    {
                        "note": "This rule skips external and public state variables"
                    },
                    {
                        "note": "See [here](https://docs.soliditylang.org/en/latest/style-guide.html#underscore-prefix-for-non-external-functions-and-variables) for further information"
                    }
                ]
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": [
                "warn",
                {
                    "strict": false
                }
            ],
            "fixable": true,
            "schema": {
                "type": "object",
                "properties": {
                    "strict": {
                        "type": "boolean"
                    }
                }
            }
        },
        "file": "/solhint/lib/rules/naming/private-vars-leading-underscore.js"
    },
    {
        "ruleId": "use-forbidden-name",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Avoid to use letters 'I', 'l', 'O' as identifiers.",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/use-forbidden-name.js"
    },
    {
        "ruleId": "var-name-mixedcase",
        "meta": {
            "type": "naming",
            "docs": {
                "description": "Variable name must be in mixedCase. (Does not check IMMUTABLES, use immutable-vars-naming)",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/naming/var-name-mixedcase.js"
    },
    {
        "ruleId": "func-order",
        "meta": {
            "type": "order",
            "docs": {
                "description": "Function order is incorrect.",
                "category": "Style Guide Rules",
                "examples": {
                    "good": [
                        {
                            "description": "Constructor is placed before other functions",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n                constructor() public {}\n                function () public payable {}\n            \n      }\n    "
                        }
                    ],
                    "bad": [
                        {
                            "description": "Constructor is placed after other functions",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n                function () public payable {}\n                constructor() public {}\n            \n      }\n    "
                        }
                    ]
                }
            },
            "isDefault": false,
            "deprecated": true,
            "deprecationMessage": "use 'ordering' instead",
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/order/func-order.js"
    },
    {
        "ruleId": "imports-on-top",
        "meta": {
            "type": "order",
            "docs": {
                "description": "Import statements must be on top.",
                "category": "Style Guide Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/order/imports-on-top.js"
    },
    {
        "ruleId": "ordering",
        "meta": {
            "type": "order",
            "docs": {
                "description": "Check order of elements in file and inside each contract, according to the style guide.",
                "category": "Style Guide Rules",
                "examples": {
                    "good": [
                        {
                            "description": "All units are in order - ^0.4.0",
                            "code": "\npragma solidity ^0.4.0;\n\nimport \"./some/library.sol\";\nimport \"./some/other-library.sol\";\n\nenum MyEnum {\n  Foo,\n  Bar\n}\n\nstruct MyStruct {\n  uint x;\n  uint y;\n}\n\ninterface IBox {\n  function getValue() public;\n  function setValue(uint) public;\n}\n\nlibrary MyLibrary {\n  function add(uint a, uint b, uint c) public returns (uint) {\n    return a + b + c;\n  }\n}\n\ncontract MyContract {\n  struct InnerStruct {\n    bool flag;\n  }\n\n  enum InnerEnum {\n    A, B, C\n  }\n\n  uint public x;\n  uint public y;\n\n  event MyEvent(address a);\n\n  constructor () public {}\n\n  fallback () external {}\n\n  function myExternalFunction() external {}\n  function myExternalConstantFunction() external constant {}\n\n  function myPublicFunction() public {}\n  function myPublicConstantFunction() public constant {}\n\n  function myInternalFunction() internal {}\n  function myPrivateFunction() private {}\n}\n"
                        },
                        {
                            "description": "All units are in order - ^0.5.0",
                            "code": "\npragma solidity ^0.5.0;\n\nimport \"./some/library.sol\";\nimport \"./some/other-library.sol\";\n\nenum MyEnum {\n  Foo,\n  Bar\n}\n\nstruct MyStruct {\n  uint x;\n  uint y;\n}\n\ninterface IBox {\n  function getValue() public;\n  function setValue(uint) public;\n}\n\nlibrary MyLibrary {\n  function add(uint a, uint b, uint c) public returns (uint) {\n    return a + b + c;\n  }\n}\n\ncontract MyContract {\n  using MyLibrary for uint;\n\n  struct InnerStruct {\n    bool flag;\n  }\n\n  enum InnerEnum {\n    A, B, C\n  }\n\n  address payable owner;\n  uint public x;\n  uint public y;\n\n  event MyEvent(address a);\n\n  modifier onlyOwner {\n    require(\n      msg.sender == owner,\n      \"Only owner can call this function.\"\n    );\n    _;\n  }\n\n  constructor () public {}\n\n  fallback () external {}\n\n  function myExternalFunction() external {}\n  function myExternalViewFunction() external view {}\n  function myExternalPureFunction() external pure {}\n\n  function myPublicFunction() public {}\n  function myPublicViewFunction() public view {}\n  function myPublicPureFunction() public pure {}\n\n  function myInternalFunction() internal {}\n  function myInternalViewFunction() internal view {}\n  function myInternalPureFunction() internal pure {}\n\n  function myPrivateFunction() private {}\n  function myPrivateViewFunction() private view {}\n  function myPrivatePureFunction() private pure {}\n}\n"
                        },
                        {
                            "description": "All units are in order - ^0.6.0",
                            "code": "\npragma solidity ^0.6.0;\n\nimport \"./some/library.sol\";\nimport \"./some/other-library.sol\";\n\nenum MyEnum {\n  Foo,\n  Bar\n}\n\nstruct MyStruct {\n  uint x;\n  uint y;\n}\n\ninterface IBox {\n  function getValue() public;\n  function setValue(uint) public;\n}\n\nlibrary MyLibrary {\n  function add(uint a, uint b, uint c) public returns (uint) {\n    return a + b + c;\n  }\n}\n\ncontract MyContract {\n  using MyLibrary for uint;\n\n  struct InnerStruct {\n    bool flag;\n  }\n\n  enum InnerEnum {\n    A, B, C\n  }\n\n  address payable owner;\n  uint public x;\n  uint public y;\n\n  event MyEvent(address a);\n\n  modifier onlyOwner {\n    require(\n      msg.sender == owner,\n      \"Only owner can call this function.\"\n    );\n    _;\n  }\n\n  constructor () public {}\n\n  receive() external payable {}\n\n  fallback () external {}\n\n  function myExternalFunction() external {}\n  function myExternalViewFunction() external view {}\n  function myExternalPureFunction() external pure {}\n\n  function myPublicFunction() public {}\n  function myPublicViewFunction() public view {}\n  function myPublicPureFunction() public pure {}\n\n  function myInternalFunction() internal {}\n  function myInternalViewFunction() internal view {}\n  function myInternalPureFunction() internal pure {}\n\n  function myPrivateFunction() private {}\n  function myPrivateViewFunction() private view {}\n  function myPrivatePureFunction() private pure {}\n}\n"
                        }
                    ],
                    "bad": [
                        {
                            "description": "State variable declaration after function",
                            "code": "\n  contract MyContract {\n    function foo() public {}\n\n    uint a;\n  }\n"
                        },
                        {
                            "description": "Library after contract",
                            "code": "\n  contract MyContract {}\n\n  library MyLibrary {}\n"
                        },
                        {
                            "description": "Interface after library",
                            "code": "\n  library MyLibrary {}\n\n  interface MyInterface {}\n"
                        },
                        {
                            "description": "Use for after state variable",
                            "code": "\ncontract MyContract {\n  uint public x;\n  \n  using MyMathLib for uint;\n}\n"
                        },
                        {
                            "description": "External pure before external view",
                            "code": "\ncontract MyContract {\n  function myExternalFunction() external {}\n  function myExternalPureFunction() external pure {}\n  function myExternalViewFunction() external view {}\n}\n"
                        },
                        {
                            "description": "Public pure before public view",
                            "code": "\ncontract MyContract {\n  function myPublicFunction() public {}\n  function myPublicPureFunction() public pure {}\n  function myPublicViewFunction() public view {}\n}\n"
                        },
                        {
                            "description": "Internal pure before internal view",
                            "code": "\ncontract MyContract {\n  function myInternalFunction() internal {}\n  function myInternalPureFunction() internal pure {}\n  function myInternalViewFunction() internal view {}\n}\n"
                        },
                        {
                            "description": "Private pure before private view",
                            "code": "\ncontract MyContract {\n  function myPrivateFunction() private {}\n  function myPrivatePureFunction() private pure {}\n  function myPrivateViewFunction() private view {}\n}\n"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/order/ordering.js"
    },
    {
        "ruleId": "visibility-modifier-order",
        "meta": {
            "type": "order",
            "docs": {
                "description": "Visibility modifier must be first in list of modifiers.",
                "category": "Style Guide Rules",
                "examples": {
                    "good": [
                        {
                            "description": "Visibility modifier placed first",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        function a() public ownable() payable {}\n      }\n    "
                        }
                    ],
                    "bad": [
                        {
                            "description": "Visibility modifier not placed first",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        function a() ownable() public payable {}\n      }\n    "
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/order/visibility-modifier-order.js"
    },
    {
        "ruleId": "avoid-call-value",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Avoid to use \".call.value()()\".",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/avoid-call-value.js"
    },
    {
        "ruleId": "avoid-low-level-calls",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Avoid to use low level calls.",
                "category": "Security Rules",
                "examples": {
                    "good": [
                        {
                            "description": "Using low level calls to transfer funds",
                            "code": "anyAddress.call{value: 1 ether}(\"\");"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Using low level calls",
                            "code": "anyAddress.call(code);\na.callcode(test1);\na.delegatecall(test1);\nanyAddress.call.value(code)();"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/avoid-low-level-calls.js"
    },
    {
        "ruleId": "avoid-sha3",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Use \"keccak256\" instead of deprecated \"sha3\".",
                "category": "Security Rules",
                "notes": [
                    {
                        "note": "Solhint allows this rule to automatically fix the code with `--fix` option"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "fixable": true,
            "schema": null
        },
        "file": "/solhint/lib/rules/security/avoid-sha3.js"
    },
    {
        "ruleId": "avoid-suicide",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Use \"selfdestruct\" instead of deprecated \"suicide\".",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/avoid-suicide.js"
    },
    {
        "ruleId": "avoid-throw",
        "meta": {
            "type": "security",
            "docs": {
                "description": "\"throw\" is deprecated, avoid to use it.",
                "category": "Security Rules",
                "notes": [
                    {
                        "note": "Solhint allows this rule to automatically fix the code with `--fix` option"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "fixable": true,
            "schema": null
        },
        "file": "/solhint/lib/rules/security/avoid-throw.js"
    },
    {
        "ruleId": "avoid-tx-origin",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Avoid to use tx.origin.",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/avoid-tx-origin.js"
    },
    {
        "ruleId": "check-send-result",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Check result of \"send\" call.",
                "category": "Security Rules",
                "examples": {
                    "good": [
                        {
                            "description": "result of \"send\" call checked with if statement",
                            "code": "if(x.send(55)) {}"
                        },
                        {
                            "description": "result of \"send\" call checked within a require",
                            "code": "require(payable(walletAddress).send(moneyAmount), \"Failed to send moneyAmount\");"
                        }
                    ],
                    "bad": [
                        {
                            "description": "result of \"send\" call ignored",
                            "code": "x.send(55);"
                        }
                    ]
                },
                "notes": [
                    {
                        "note": "Rule will rise false positive on this: `bool success = walletAddress.send(amount); require(success, \"Failed to send\"); ` "
                    },
                    {
                        "note": "Rule will skip ERC777 \"send\" function to prevent false positives"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/check-send-result.js"
    },
    {
        "ruleId": "compiler-version",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Compiler version must satisfy a semver requirement.",
                "category": "Security Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "error"
                    },
                    {
                        "description": "Semver requirement",
                        "default": "^0.8.0"
                    }
                ]
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": [
                "error",
                "^0.8.0"
            ],
            "schema": {
                "type": "string"
            }
        },
        "file": "/solhint/lib/rules/security/compiler-version.js"
    },
    {
        "ruleId": "func-visibility",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Explicitly mark visibility in function.",
                "category": "Security Rules",
                "options": [
                    {
                        "description": "Rule severity. Must be one of \"error\", \"warn\", \"off\".",
                        "default": "warn"
                    },
                    {
                        "description": "A JSON object with a single property \"ignoreConstructors\" specifying if the rule should ignore constructors. (**Note: This is required to be true for Solidity >=0.7.0 and false for <0.7.0**)",
                        "default": "{\"ignoreConstructors\":false}"
                    }
                ],
                "examples": {
                    "good": [
                        {
                            "description": "Functions explicitly marked with visibility",
                            "code": "function b() internal { }\nfunction b() external { }\nfunction b() private { }\nfunction b() public { }\nconstructor() public { }"
                        }
                    ],
                    "bad": [
                        {
                            "description": "Functions without explicitly marked visibility",
                            "code": "function b() { }"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": [
                "warn",
                {
                    "ignoreConstructors": false
                }
            ],
            "schema": {
                "type": "object",
                "properties": {
                    "ignoreConstructors": {
                        "type": "boolean"
                    }
                }
            }
        },
        "file": "/solhint/lib/rules/security/func-visibility.js"
    },
    {
        "ruleId": "mark-callable-contracts",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Explicitly mark all external contracts as trusted or untrusted.",
                "category": "Security Rules",
                "examples": {
                    "good": [
                        {
                            "description": "External contract name with \"Trusted\" prefix",
                            "code": "TrustedBank.withdraw(100);"
                        }
                    ],
                    "bad": [
                        {
                            "description": "External contract name without \"Trusted\" prefix",
                            "code": "Bank.withdraw(100);"
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "deprecated": true,
            "schema": null
        },
        "file": "/solhint/lib/rules/security/mark-callable-contracts.js"
    },
    {
        "ruleId": "multiple-sends",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Avoid multiple calls of \"send\" method in single transaction.",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/multiple-sends.js"
    },
    {
        "ruleId": "no-complex-fallback",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Fallback function must be simple.",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/no-complex-fallback.js"
    },
    {
        "ruleId": "no-inline-assembly",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Avoid to use inline assembly. It is acceptable only in rare cases.",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/no-inline-assembly.js"
    },
    {
        "ruleId": "not-rely-on-block-hash",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Do not rely on \"block.blockhash\". Miners can influence its value.",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/not-rely-on-block-hash.js"
    },
    {
        "ruleId": "not-rely-on-time",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Avoid making time-based decisions in your business logic.",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": false,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/not-rely-on-time.js"
    },
    {
        "ruleId": "reentrancy",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Possible reentrancy vulnerabilities. Avoid state changes after transfer.",
                "category": "Security Rules",
                "examples": {
                    "good": [
                        {
                            "description": "Invulnerable Contract 1",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n                mapping(address => uint) private shares;\n\n                function b() external {\n                    uint amount = shares[msg.sender];\n                    shares[msg.sender] = 0;\n                    msg.sender.transfer(amount);\n                }\n            \n      }\n    "
                        },
                        {
                            "description": "Invulnerable Contract 2",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n                mapping(address => uint) private shares;\n\n                function b() external {\n                    uint amount = shares[msg.sender];\n                    user.test(amount);\n                    shares[msg.sender] = 0;\n                }\n            \n      }\n    "
                        },
                        {
                            "description": "Invulnerable Contract 3",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n        function b() public {\n          \n                uint[] shares;\n                uint amount = shares[msg.sender];\n                msg.sender.transfer(amount);\n                shares[msg.sender] = 0;\n            \n        }\n    \n      }\n    "
                        }
                    ],
                    "bad": [
                        {
                            "description": "Vulnerable Contract 1",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n                mapping(address => uint) private shares;\n\n                function b() external {\n                    uint amount = shares[msg.sender];\n                    bool a = msg.sender.send(amount);\n                    if (a) { shares[msg.sender] = 0; }\n                }\n            \n      }\n    "
                        },
                        {
                            "description": "Vulnerable Contract 2",
                            "code": "\n      pragma solidity 0.4.4;\n        \n        \n      contract A {\n        \n                mapping(address => uint) private shares;\n\n                function b() external {\n                    uint amount = shares[msg.sender];\n                    msg.sender.transfer(amount);\n                    shares[msg.sender] = 0;\n                }\n            \n      }\n    "
                        }
                    ]
                }
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/reentrancy.js"
    },
    {
        "ruleId": "state-visibility",
        "meta": {
            "type": "security",
            "docs": {
                "description": "Explicitly mark visibility of state.",
                "category": "Security Rules"
            },
            "isDefault": false,
            "recommended": true,
            "defaultSetup": "warn",
            "schema": null
        },
        "file": "/solhint/lib/rules/security/state-visibility.js"
    }
]